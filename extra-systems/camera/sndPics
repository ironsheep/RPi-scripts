#!/bin/bash
SCRIPT=${0##*/}
SCRIPT_VERSION="1.0"

# =============================================================================
# Usage info
#
show_help() {
	# takes $1 as as desired exit code
ERROR_LEVEL=$1
cat  >&2 << EOF

Usage: ${SCRIPT} [-dhv] 

 $SCRIPT v${SCRIPT_VERSION} send an hours\' worth of jpg/avi files to pimon1
 
where:
    -h          Display this (h)elp and exit
    -d          Enable script-(d)ebug output
    -v          Enable (v)erbose mode. Can be used multiple times for increased
                 verbosity.
                 
Typical Use Cases:

	${SCRIPT} -h     		    # display this help text 
	
EOF
	exit ${ERROR_LEVEL}
}

# =============================================================================
#  Simple message printing functions
#
warningMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}:WARNING- ${MESSAGE}" >&2
}

warningTimedMessage () {
# takes $1 as message text
	NOWHHMM=`date +%H:%M:%S`
	MESSAGE=$1
	echo "${SCRIPT}:WARNING- ${MESSAGE}: ${NOWHHMM}" >&2
}

infoMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}:INFO- ${MESSAGE}" >&2
}

errorMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}:ERROR- ${MESSAGE}" >&2
}

fatalMessage () {
# takes $1 as message text and $2 as exit code
	MESSAGE=$1
	ERROR_LEVEL=$2
	errorMessage "${MESSAGE}"
	exit ${ERROR_LEVEL}
}

debugMessage () {
# takes $1 as message text and (optional) $2 as gating debug level
#  ONLY displays message if DEBUG is enabled
## TODO add gating level logic
	MESSAGE=$1
	GATING_LEVEL=$2
	if [ -n "${DEBUG}" ]; then
		echo "${SCRIPT}(DBG): ${MESSAGE}" >&2
	fi
}

progressMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}: ${MESSAGE}" 
}

verboseMessage () {
# takes $1 as message text and $2 as gating verbose level
#   if gating <= current then display message
## TODO add gating level logic
	MESSAGE=$1
	GATING_LEVEL=$2
	#echo "${SCRIPT}:Verbose(${GATING_LEVEL})- ${MESSAGE}" >&2
	
	if [ ${VERBOSE_LEVEL} -gt 0 ]; then
		echo "${SCRIPT}:Verbose- ${MESSAGE}" >&2
	fi
}

verboseTimedMessage () {
# takes $1 as message text and $2 as gating verbose level
#   if gating <= current then display message
## TODO add gating level logic
	MESSAGE=$1
	GATING_LEVEL=$2
	NOWHHMM=`date +%H:%M:%S`
	#echo "${SCRIPT}:Verbose(${GATING_LEVEL})- ${MESSAGE}" >&2
	
	if [ ${VERBOSE_LEVEL} -gt 0 ]; then
		echo "${SCRIPT}:Verbose- ${MESSAGE}: ${NOWHHMM}" >&2
	fi
}



# =============================================================================
# Initialize our variables
#
export DEBUG=""
export DEBUG_LEVEL=0
export VERBOSE_LEVEL=0
export UNDER_AUTOMATOR=0

# =============================================================================
#  Process the command line arguments
#
OPTIND=1 # Reset is necessary if getopts was used previously in the script.  It is a good idea to make this local in a function.
while getopts "hdv" opt; do
    case "$opt" in
        h)
            show_help 0
            ;;
        d)
        	  export DEBUG_LEVEL=$((DEBUG_LEVEL+1))
        	  export DEBUG=yes
        	  if [ ${DEBUG_LEVEL} -eq 1 ]; then
        	  	# when first setting debug set this too
        	  	export VERBOSE_LEVEL=$((VERBOSE_LEVEL+1))
        	  fi
            ;;
        v)
        	  export VERBOSE_LEVEL=$((VERBOSE_LEVEL+1))
        	  debugMessage "verbose set to ${VERBOSE_LEVEL}!"
            ;;
        '?')
        	  echo "$SCRIPT: Question Mark!" >&2
            show_help 0
            ;;
    esac
done

shift "$((OPTIND-1))" # Shift off the options and optional --.


# =============================================================================
#  final checks and setup before execution
#

HOSTNAME=`uname -n`
HOME_PI=pimon1

if [ ! "${HOSTNAME}" = "picam" ]; then
	echo "${SCRIPT}:ERROR- must run on \"picam\", aborting..." >&2 
	exit 1
fi

TARGET_DIR="/var/status/${HOSTNAME}/fileXfer"
TMP_DIR=~/tmp/${SCRIPT}
if [ ! -d ${TMP_DIR} ]; then
 (set -x;mkdir -p ${TMP_DIR})
fi

PICS_DIR="/tmp/motion"


if [ "${HOSTNAME}" != "${HOME_PI}" ]; then
  USE_SCP=YES
else
  USE_SCP=NO
fi
debugMessage "USE_SCP=[${USE_SCP}]"

# copy any waiting CHECK-RESULT files to our local dir
if [ "${USE_SCP}" = "YES" ]; then
  scp -p pi@pimon1.home:"${TARGET_DIR}/*Result" "${TMP_DIR}"
else
  (set -x;cp -p "${TARGET_DIR}/*Result" "${TMP_DIR}")
fi

# now do what result file indicates...
#  - if GOOD remove files for given key
#  - if BAD send files again

RESULT_FILES_CT=`ls -1 ${TMP_DIR}/*Result 2>/dev/null | wc -l`
debugMessage "RESULT_FILES_CT=[${RESULT_FILES_CT}]"
if [ "${RESULT_FILES_CT}" -gt 0 ]; then
	debugMessage "we have RESULTS let's handle them"
else 
	debugMessage "No RESULT files to be processed, moving on..."
fi


if [ "${RESULT_FILES_CT}" -gt 0 ]; then
	DONE_FILES_CT=`ls -1 ${TMP_DIR}/*.done 2>/dev/null | wc -l`
	debugMessage "DONE_FILES_CT=[${DONE_FILES_CT}]"
	if [ "${DONE_FILES_CT}" -gt 0 ]; then
		debugMessage "we have DONE files let's handle them"
		(set -x;rm -f ${TMP_DIR}/*.done)
	else 
		debugMessage "No DONE files to be processed, moving on..."
	fi
   
	for RSLTFIL in `ls -1 ${TMP_DIR}/*Result`; do
		ISGOOD=`echo ${RSLTFIL} | grep -i goodresult`
		ISBAD=`echo ${RSLTFIL} | grep -i badresult`
		debugMessage "ISGOOD=[${ISGOOD}]"
		debugMessage "ISBAD=[${ISBAD}]"
		if [ -n "${ISGOOD}" ]; then
			# handle GOOD checksum at far end
			THISKEY=`basename ${ISGOOD} .goodResult`
			debugMessage "THISKEY=[${THISKEY}]"
			verboseTimedMessage "Removing images sent successfully"
			MD5_FILE="${TMP_DIR}/${THISKEY}.sum"
			for SRCPIC in `cat "${MD5_FILE}" | awk '{ print $2; }'`; do
				#debugMessage "Would: rm -f [${SRCPIC}]"
				if [ -f "${SRCPIC}" ]; then
					(set -x; sudo rm -f "${SRCPIC}")
				fi
			done
			verboseTimedMessage "Removing send files too"
			TAR_FILE="${TMP_DIR}/${THISKEY}.tar.gz"
			MD5_TARFILE="${TMP_DIR}/${THISKEY}.tar.sum"
			THISKEY_FLG="${TMP_DIR}/${THISKEY}.sent"
			THISKEY_RSLT="${TMP_DIR}/${THISKEY}.goodResult"
			THISKEY_DONE="${TMP_DIR}/${THISKEY}.done"
			#fatalMessage "development early exit - would remove files: ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE} ${THISKEY_FLG} ${THISKEY_RSLT}" 0
			(set -x;rm -f ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE} ${THISKEY_FLG} ${THISKEY_RSLT})
			echo "$SCRIPT: files removed" >${THISKEY_DONE}
			if [ "${USE_SCP}" = "YES" ]; then
				scp -p ${THISKEY_DONE} pi@pimon1.home:${TARGET_DIR}
			else
				(set -x;cp -p ${THISKEY_DONE} ${TARGET_DIR})
			fi
		else
		    # handle BAD checksum at far end
			THISKEY=`basename ${ISBAD} .badResult`
			debugMessage "THISKEY=[${THISKEY}]"
		    # resend files
			MD5_FILE="${TMP_DIR}/${THISKEY}.sum"
			TAR_FILE="${TMP_DIR}/${THISKEY}.tar.gz"
			MD5_TARFILE="${TMP_DIR}/${THISKEY}.tar.sum"
			THISKEY_RSLT="${TMP_DIR}/${THISKEY}.badResult"
			#fatalMessage "development early exit - would resend files: ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE} " 0
			(set -x;rm -f ${THISKEY_RSLT})
			if [ "${USE_SCP}" = "YES" ]; then
				scp -p ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE} pi@pimon1.home:${TARGET_DIR}
			else
				(set -x;cp -p ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE} ${TARGET_DIR})
			fi
		fi
	done
fi

#fatalMessage "development early exit" 0


# build up files to send
#  - list of files for this attempt
#  - file: list of md5sums for files in this attempt

verboseTimedMessage "calculating keys"

KEYS_FILE="${TMP_DIR}/${SCRIPT}-keys.dat"
rm -f ${KEYS_FILE}
TMP_KEYS_FILE="${TMP_DIR}/f1"
rm -f ${TMP_KEYS_FILE}

for PIC in `find ${PICS_DIR} -type f -print | grep -E "jpg|avi" | sort -n`; do
	PICNAME=`basename "${PIC}"`
	REGEXP="^[0-9]{1,3}\-([0-9]{10,10}).*$"
	#echo "pic=${PICNAME}"
	[[ ${PICNAME} =~ ${REGEXP} ]] 
	dateKey=${BASH_REMATCH[1]}
	echo "${dateKey}" >>${TMP_KEYS_FILE}
done
cat  ${TMP_KEYS_FILE} | sort -u >${KEYS_FILE}
rm -f ${TMP_KEYS_FILE}

verboseTimedMessage "checking findings"

for PICKEY in `cat ${KEYS_FILE}`; do
    FILESFOUND=`ls ${PICS_DIR}/*${PICKEY}* | wc -l`
    verboseMessage "key=${PICKEY}: ct=${FILESFOUND}"
done

# if we've more than 1 key we can send another if not already sent
KEYS_CT=`cat ${KEYS_FILE} | wc -l`
debugMessage "KEYS_CT=[${KEYS_CT}]"
if [ "${KEYS_CT}" -gt 1 ]; then
	debugMessage "we CAN send one!"
else 
	fatalMessage "No files to be sent, Done" 0
fi

# get the earliest key
THISKEY=`head -1 ${KEYS_FILE}`
verboseTimedMessage "processing ${THISKEY}"

# build up our list of files for this key
TMP_FILE="${TMP_DIR}/${SCRIPT}-files.lst"
ls -1 ${PICS_DIR}/*${THISKEY}* > ${TMP_FILE}
    
FILESCOUNT=`wc -l ${TMP_FILE}`
verboseTimedMessage "found ${FILESCOUNT} files"

# check if we've already handled THISKEY
THISKEY_FLG="${TMP_DIR}/${SCRIPT}-${THISKEY}.sent"
if [ -f "${THISKEY_FLG}" ]; then
	ls -l ${TMP_DIR}/${SCRIPT}-${THISKEY}*
	warningTimedMessage "already sent files for this key, aborting"
	exit 1
fi

# create md5 sums file
MD5_FILE="${TMP_DIR}/${SCRIPT}-${THISKEY}.sum"
md5sum ${PICS_DIR}/*${THISKEY}* >${MD5_FILE} 2>&1

# create tarball
TAR_FILE="${TMP_DIR}/${SCRIPT}-${THISKEY}.tar.gz"
TAR_FILENAME=`basename ${TAR_FILE}`

tar -czf ${TAR_FILE} ${PICS_DIR}/*${THISKEY}*

MD5_TARFILE="${TMP_DIR}/${SCRIPT}-${THISKEY}.tar.sum"
cd ${TMP_DIR}
md5sum ${TAR_FILENAME} >${MD5_TARFILE} 2>&1
cd -

verboseTimedMessage "generated the following files"

ls -l ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE}

if [ "${USE_SCP}" = "YES" ]; then
  scp -p ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE} pi@pimon1.home:${TARGET_DIR}
else
  (set -x;cp -p ${MD5_FILE} ${TAR_FILE} ${MD5_TARFILE} ${TARGET_DIR})
fi

verboseTimedMessage "Done"
exit 0
