#!/bin/bash
SCRIPT=${0##*/}
SCRIPT_VERSION="1.0"

# =============================================================================
# Usage info
#
show_help() {
	# takes $1 as as desired exit code
ERROR_LEVEL=$1
cat  >&2 << EOF

Usage: ${SCRIPT} [-dhv] 

 $SCRIPT v${SCRIPT_VERSION} process and archive an hours\' worth of jpg/avi files sent by picam-wifi
 
where:
    -h          Display this (h)elp and exit
    -d          Enable script-(d)ebug output
    -v          Enable (v)erbose mode. Can be used multiple times for increased
                 verbosity.
                 
Typical Use Cases:

	${SCRIPT} -h     		    # display this help text 
	
EOF
	exit ${ERROR_LEVEL}
}

# =============================================================================
#  Simple message printing functions
#
warningMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}:WARNING- ${MESSAGE}" >&2
}

warningTimedMessage () {
# takes $1 as message text
	NOWHHMM=`date +%H:%M:%S`
	MESSAGE=$1
	echo "${SCRIPT}:WARNING- ${MESSAGE}: ${NOWHHMM}" >&2
}

infoMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}:INFO- ${MESSAGE}" >&2
}

errorMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}:ERROR- ${MESSAGE}" >&2
}

fatalMessage () {
# takes $1 as message text and $2 as exit code
	MESSAGE=$1
	ERROR_LEVEL=$2
	errorMessage "${MESSAGE}"
	exit ${ERROR_LEVEL}
}

debugMessage () {
# takes $1 as message text and (optional) $2 as gating debug level
#  ONLY displays message if DEBUG is enabled
## TODO add gating level logic
	MESSAGE=$1
	GATING_LEVEL=$2
	if [ -n "${DEBUG}" ]; then
		echo "${SCRIPT}(DBG): ${MESSAGE}" >&2
	fi
}

progressMessage () {
# takes $1 as message text
	MESSAGE=$1
	echo "${SCRIPT}: ${MESSAGE}" 
}

verboseMessage () {
# takes $1 as message text and $2 as gating verbose level
#   if gating <= current then display message
## TODO add gating level logic
	MESSAGE=$1
	GATING_LEVEL=$2
	#echo "${SCRIPT}:Verbose(${GATING_LEVEL})- ${MESSAGE}" >&2
	
	if [ ${VERBOSE_LEVEL} -gt 0 ]; then
		echo "${SCRIPT}:Verbose- ${MESSAGE}" >&2
	fi
}

verboseTimedMessage () {
# takes $1 as message text and $2 as gating verbose level
#   if gating <= current then display message
## TODO add gating level logic
	MESSAGE=$1
	GATING_LEVEL=$2
	NOWHHMM=`date +%H:%M:%S`
	#echo "${SCRIPT}:Verbose(${GATING_LEVEL})- ${MESSAGE}" >&2
	
	if [ ${VERBOSE_LEVEL} -gt 0 ]; then
		echo "${SCRIPT}:Verbose- ${MESSAGE}: ${NOWHHMM}" >&2
	fi
}



# =============================================================================
# Initialize our variables
#
export DEBUG=""
export DEBUG_LEVEL=0
export VERBOSE_LEVEL=0
export UNDER_AUTOMATOR=0

# =============================================================================
#  Process the command line arguments
#
OPTIND=1 # Reset is necessary if getopts was used previously in the script.  It is a good idea to make this local in a function.
while getopts "hdv" opt; do
    case "$opt" in
        h)
            show_help 0
            ;;
        d)
        	  export DEBUG_LEVEL=$((DEBUG_LEVEL+1))
        	  export DEBUG=yes
        	  if [ ${DEBUG_LEVEL} -eq 1 ]; then
        	  	# when first setting debug set this too
        	  	export VERBOSE_LEVEL=$((VERBOSE_LEVEL+1))
        	  fi
            ;;
        v)
        	  export VERBOSE_LEVEL=$((VERBOSE_LEVEL+1))
        	  debugMessage "verbose set to ${VERBOSE_LEVEL}!"
            ;;
        '?')
        	  echo "$SCRIPT: Question Mark!" >&2
            show_help 0
            ;;
    esac
done

shift "$((OPTIND-1))" # Shift off the options and optional --.


# =============================================================================
#  final checks and setup before execution
#

HOSTNAME=`uname -n`
HOME_PI=pimon1

# files arrive here from cam (md5 and tar.gz pairs)
SRC_DIR="/var/status/picam/fileXfer"

# unpacked files get archived here once verified
DST_DIR="/media/data/archive/cameras/cam0/byDate"

# place for our xfer files until they age-out
WEEK_HOLD_DIR=/media/data/weekHold

if [ ! -d ${SRC_DIR} ]; then
	fatalMessage "REQUIRED DIR MISSING - SRC_DIR=[${SRC_DIR}], abort!" 1
fi
if [ ! -d "${WEEK_HOLD_DIR}" ]; then
	fatalMessage "REQUIRED DIR MISSING - WEEK_HOLD_DIR=[${WEEK_HOLD_DIR}], abort!" 1
fi

NOW=`date +%y%m%d-%H%M%S`

WRK_DIR="/tmp/unpack-${NOW}"
mkdir -p ${WRK_DIR}

if [ ! -d ${WRK_DIR} ]; then
	fatalMessage "failed to create WRK_DIR [${WRK_DIR}], abort!" 1
fi

STARTING_DIR=`pwd`

#
# move into soure dir and check received files
#
cd ${SRC_DIR}
# - locate any files waiting to processed
# - if camera took action then remove flags for camera
DONE_FILES_CT=`ls -1 *.done 2>/dev/null | wc -l`
debugMessage "DONE_FILES_CT=[${DONE_FILES_CT}]"
if [ "${DONE_FILES_CT}" -gt 0 ]; then
	debugMessage "we have DONE files let's handle them"
	for DONEFIL in `ls -1 *.done`; do
		THISKEY=`basename ${DONEFIL} .done`
		debugMessage "THISKEY=[${THISKEY}]"
		(set -x;rm -f "${DONEFIL}" "${THISKEY}.goodResult")
	done
else 
	debugMessage "No DONE files to be processed, moving on..."
fi

#  - if found one let's process it and then be done

#ls -1 *.tar.sum  2>/dev/null
SEND_FILES_CT=`ls -l *.tar.sum 2>/dev/null | wc -l`
debugMessage "SEND_FILES_CT=[${SEND_FILES_CT}]"
if [ "${SEND_FILES_CT}" -gt 0 ]; then
	debugMessage "> 0!"
else 
	debugMessage "No files to be processed, Done"
	exit 0
fi

#  - (1) verify sum and generate GOOD copy flag file for picam to pick up
SEND_FILENAME=`ls -1 *.tar.sum 2>/dev/null`
debugMessage "SEND_FILENAME=[${SEND_FILENAME}]"

SEND_FILEKEY=`basename ${SEND_FILENAME} .tar.sum`
if [ -z "${SEND_FILEKEY}" ]; then
	cd ${STARTING_DIR}
	fatalMessage "failed to determine FILE KEY, abort!" 1
fi
debugMessage "SEND_FILEKEY=[${SEND_FILEKEY}]"

CHECK_FILE="${SEND_FILEKEY}.check-status"

# remove any prior result files for this key
RSLT_SUFFIX_GOOD=".goodResult"
RSLT_SUFFIX_BAD=".badResult"
OLD_FILE1="${SEND_FILEKEY}${RSLT_SUFFIX_BAD}"
if [ -f ${OLD_FILE1} ]; then
	(set -x; rm -f ${OLD_FILE1})
fi
OLD_FILE2="${SEND_FILEKEY}${RSLT_SUFFIX_GOOD}"
if [ -f ${OLD_FILE2} ]; then
	(set -x; rm -f ${OLD_FILE2})
fi

# determine and write new result file for this key
(set -x;md5sum -c ${SEND_FILEKEY}.tar.sum >${CHECK_FILE})
CHK_RSLT=`cat ${CHECK_FILE} | awk '{ print $2 }'`
debugMessage "CHK_RSLT=[${CHK_RSLT}]"

RSLT_SUFFIX=${RSLT_SUFFIX_GOOD}
if [ "${CHK_RSLT}" = "OK" ]; then
	debugMessage "[${CHK_RSLT}] good send!"
else
	debugMessage "[${CHK_RSLT}] BAD send"
	RSLT_SUFFIX=${RSLT_SUFFIX_BAD}
fi

# move our check results to final file name
RSLT_FILE="${SEND_FILEKEY}${RSLT_SUFFIX}"
debugMessage "RSLT_FILE=[${RSLT_FILE}]"
mv ${CHECK_FILE} ${RSLT_FILE}

if [ -n "${DEBUG}" ]; then
	ls -l
fi

if [ "${RSLT_SUFFIX}" = "${RSLT_SUFFIX_BAD}" ]; then
	cd ${STARTING_DIR}
	fatalMessage "CHECKSUM FAIL - bad .tar.gz file copy, abort!" 1
fi

cd ${WRK_DIR}
#  - (2) go unpack files and archive them
(set -x; tar -xzf "${SRC_DIR}/${SEND_FILEKEY}.tar.gz")
debugMessage "Unpacked files in dir=[${WRK_DIR}]"

KEYFILES_ROOTDIR="${WRK_DIR}/tmp/motion"

DST_DIR="/media/data/archive/cameras/cam0/byDate"

for FTYPE in "jpg" "avi"; do
	for PIC in `find ${KEYFILES_ROOTDIR} -name "*.${FTYPE}"`; do
		PICNAME=`basename "${PIC}"`
		REGEXP="^[0-9]{1,3}\-([0-9]{4,4})([0-9]{2,2})([0-9]{2,2}).*$"
		#debugMessage "pic=${PICNAME}"
		[[ ${PICNAME} =~ ${REGEXP} ]] 
		year=${BASH_REMATCH[1]}
		month=${BASH_REMATCH[2]}
		day=${BASH_REMATCH[3]}
		#debugMessage "  yyyy=${year}, mm=${month}, dd=${day}"
		
		TARGET_DIR="${DST_DIR}/${year}/${month}/${day}"
		#debugMessage "TARGET_DIR=[${TARGET_DIR}]"
		TARGET_FILE="${TARGET_DIR}/${PICNAME}"
		#debugMessage "TARGET_FILE=[${TARGET_FILE}]"
		#continue
		
		if [ ! -d ${TARGET_DIR} ]; then
			(set -x;mkdir -p "${TARGET_DIR}")
		fi
		# this is a known good file move it unconditionally
		(set -x;sudo mv ${PIC} ${TARGET_DIR})
		# conditionally move file (if not already there)
		#if [ ! -f "${TARGET_FILE}" ]; then
		#   (set -x;sudo mv ${PIC} ${TARGET_DIR})
		#else
		#   echo "$SCRIPT: Skipping file [${PICNAME}] already in target locn" >&2
		#fi
		if [ ! -f "${TARGET_FILE}" ]; then
			cd ${STARTING_DIR}
			fatalMessage "FILE MOVE FAIL - file didn't arrive at target location [${TARGET_FILE}], abort!" 1
		fi
	done
done

# fail if remaining is NOT empty dir tree
REMAINING_FILES_CT=`find ${KEYFILES_ROOTDIR} -type f | wc -l`
debugMessage "REMAINING_FILES_CT=[${REMAINING_FILES_CT}]"
if [ "${REMAINING_FILES_CT}" -gt 0 ]; then
	cd ${STARTING_DIR}
	fatalMessage "FILE MOVE FAIL - some files didn't get archived, abort!" 1
fi

# leave our temp dir
cd ${SRC_DIR}
# remove temp dir (empty dir tree)
(set -x; rm -rf "${WRK_DIR}")
#debugMessage "would removed empty dir ${WRK_DIR}"

#  - (3) tmp archive source files (keep for 1 week then delete?)

(set -x;mv ${SEND_FILEKEY}*.gz ${SEND_FILEKEY}*.sum ${WEEK_HOLD_DIR})

cd ${STARTING_DIR}

